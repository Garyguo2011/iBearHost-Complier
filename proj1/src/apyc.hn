/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%{
  #include <string>
  #include <stack>
  #include "apyc.h"
  #include "ast.h"

  using namespace std;

  /** Make sure garbage collection is initialized. */
  static GCINIT _gcdummy;

  static AST_Ptr theTree;

  /* Utilities */

  /** Return a new ID node, where the text of the identifier is given by
   *  TOKEN. */
  static AST_Ptr make_id (const char* token, Location_Type loc);

  /** Return a new SPECIALID node, where the text of the identifier is given by
   *  TOKEN. */
  static AST_Ptr make_specialId (const char* token, Location_Type loc);
  static AST_Ptr make_intLiteral (const char* text, Location_Type loc);

  /* Variables for lexer */
  static int paren_count = 0 ;
  static int square_bracket_count = 0;
  static int curly_bracket_count = 0;
  static int loop_count = 0;
  static int func_count = 0;
  static int if_count = 0;
  static bool has_class = false;

  static stack<int> indent_unit;
  static int total_blank_count = 0;
  static bool first_nonblank_line = true;
 
%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between
 * syntactic categories (like IF) and the token strings defined in these
 * %token declarations (like "if").
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"!
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */


%token PRINTLN "@println"
%token PRINT "@print"
%token EMPTY
%token MODULE "@module"
%token ID "@id"
%token STRING_LITERAL "@string_literal"
%token INT_LITERAL "@int_literal"
%token AND "and"
%token BREAK "@break"
%token CLASS "@class"
%token CONTINUE "@continue"
%token DEF "@def"
%token ELIF "elif"
%token ELSE "else"
%token FOR "for"
%token IF "if"
%token IN "in"
%token IS "is"
%token NOT "not"
%token OR "or"
%token RETURN "@return"
%token WHILE "while"
%token STRING "@string"
%token RAWSTRING "@rawstring"
%token INDENT
%token DEDENT
%token NEWLINE
%token COMMENT
%token BLANKLINE
%token INDENT_BLANKLINE

%token LEFT_PAREN
%token RIGHT_PAREN
%token LEFT_SQUARE_BRACKET
%token RIGHT_SQUARE_BRACKET
%token LEFT_CURLY_BRACKET
%token RIGHT_CURLY_BRACKET

%token ATTRIBUTEREF "@attributeref"
%token SUBSCRIPT "@subscript"
%token SUBSCRIPT_ASSIGN "@subscript_assign"
%token SLICE "@slice"
%token SLICE_ASSIGN "@slice_assign"
%token NEXT_VALUE "@next_value"
%token PASS "pass"

%token UNOP "@unop"
%token BINOP "@binop"
%token DICT_DISPLAY "@dict_display"
%token PAIR "@pair"
%token LIST_DISPLAY "@list_display"
%token TUPLE "@tuple"
%token SPECIALID
%token STMTLIST "@stmt_list"
%token BLOCK "@block"
%token FORMALSLIST "@formals_list"
%token ASSIGN "@assign"
%token TARGETLIST "@target_list"
%token CALL "@call"

%token COMPARE "@compare"
%token LEFT_COMPARE "@left_compare"
%token IF_EXPR "@if_expr"
%token TYPE "@type"
%token TYPED_ID "@typed_id"
%token TYPE_VAR "@type_var"
%token TYPE_LIST "@type_list"
%token TYPE_FORMALS "@type_formals_list"
%token FUNCTION_TYPE "@function_type"
%token NATIVE "@native"

/* FIXME: MORE... */

/* GLR parsing is useful for cases where the parser must make a reduction before
 * it has sufficient information to know which reduction to make.  For example,
 * consider a statement that begins
 *      a[i], b[j], c
 * (it's not useful, but is valid Python as it stands).  As a tuple, this
 * consists of a list of expressions.  a[i] is a subscription, and corresponds
 * to a (subscript ...) AST.  But if we have
 *      a[i], b[j], c = L
 * then the a[i] should create a subscript_assign.  If you try to handle this
 * by having two rules for subscription, one for the first case and one
 * for the second, the parser has to decide which to choose just after seeing
 * seeing a[i], but long before seeing "=", which is how one tells which
 * translation is appropriate.  A GLR parser will hold off on this decision
 * until is reaches the =. */

%glr-parser

/* If you use the GLR features, Bison will report conflicts.  Without GLR,
 * a conflict generally means an error.  With GLR, it could mean an error,
 * or it could indicate conflicts that the GLR algorithm will correctly resolve.
 * There's really no way to know without testing.  When you get conflicts
 * THAT YOU EXPECT you can record here these expectations by reporting how
 * many reduce/reduce (%expect-rr) and shift-reduce (%expect) you expect.
 * Before increasing these counts, make sure you understand what causes your
 * conflicts and that GLR will resolve them.  Don't expect too many (our solution
 * has 20 overall) and try to remove conflicts rather than tolerating them.
 * A conflict will occur when there is a situation where Bison cannot decide
 * on the basis of the input so far whether to perform a reduction.  The
 * conflict is OK if it will become clear later on in the input what should
 * have been done. */
%expect-rr 30
%expect 1

%left OR
%left AND
%left "<" "<=" ">" ">=" "!=" "==" "is" "is not" "in" "not in"
%left "+" "-"
%left "*" "/" "%"
%left "**"

%%
program : (NEWLINE! | statement)*           { theTree = $^(MODULE, $*); $$ = NULL; }
    ;

/************** ATOMS ********************/
identifier :
    ID                                        
    ;

atom : 
      identifier 
    | literal
    | enclosure
    | SPECIALID
    ;

enclosure : 
      parenth_form
    | list_display
    | dict_display
    ;
/******************************************/
/********** LITERALS **********************/
literal :
      stringliteral
    | INT_LITERAL
    ;

stringliteral :
      stringliteralpiece+           { $$ = $^(STRING_LITERAL, $*); }
    ;

stringliteralpiece :
      STRING                       
    | RAWSTRING             
    ;
/******************************************/

/********** COLLECTIONS *******************/
parenth_form : LEFT_PAREN! RIGHT_PAREN! {$$ = $^(TUPLE)}
    | LEFT_PAREN! expression RIGHT_PAREN!
    | LEFT_PAREN! expression (","! expression)+ ","!? RIGHT_PAREN! { $$ = $^(TUPLE, $*); }
    | LEFT_PAREN! expression ","! RIGHT_PAREN! {$$ = $^(TUPLE, $*); } 
    ;

list_display : LEFT_SQUARE_BRACKET! RIGHT_SQUARE_BRACKET!  {$$ = $^(LIST_DISPLAY); }
    | LEFT_SQUARE_BRACKET! expression (","! expression)* ","!? RIGHT_SQUARE_BRACKET!  {$$ = $^(LIST_DISPLAY, $*); }
    ;   

dict_display : LEFT_CURLY_BRACKET! RIGHT_CURLY_BRACKET! {$$ = $^(DICT_DISPLAY);}
    | LEFT_CURLY_BRACKET! pair_list RIGHT_CURLY_BRACKET!
    ;

pair_list : pair (","! pair)* ","!? { $$ = $^(DICT_DISPLAY, $*); }
    ; 

pair : l=expression ":"! expression { $$ = $^(PAIR, $*); }
    ;
/*******************************************/

/**************** PRIMARIES ****************/

primary :
      atom
    | attributeref
    | subscription
    | slicing
    | call 
    ;

attributeref :
      primary '.'! identifier       { $$ = $^(ATTRIBUTEREF, $*); }
    ;

subscription :
      e=primary LEFT_SQUARE_BRACKET! expression RIGHT_SQUARE_BRACKET!                         { $$ = $^(SUBSCRIPT, make_id("__getitem__",$e.loc()),$*); }
    ;

slicing :
      e=primary LEFT_SQUARE_BRACKET! l=lower_bound ':'! u=upper_bound RIGHT_SQUARE_BRACKET!       { $$ = $^(SLICE, make_id("__getslice__",$e.loc()), $e, $l, $u);}
    | e=primary LEFT_SQUARE_BRACKET! l=lower_bound ':'! RIGHT_SQUARE_BRACKET!                     { $$ = $^(SLICE, make_id("__getslice__",$e.loc()), $e, $l, make_intLiteral ("1073741823", $e.loc()));}
    | e=primary LEFT_SQUARE_BRACKET! ':'! u=upper_bound RIGHT_SQUARE_BRACKET!                     { $$ = $^(SLICE, make_id("__getslice__",$e.loc()), $e, make_intLiteral ("0", $e.loc()), $u);}
    | e=primary LEFT_SQUARE_BRACKET! ':'! RIGHT_SQUARE_BRACKET!                     { $$ = $^(SLICE, make_id("__getslice__",$e.loc()), $e, make_intLiteral ("0", $e.loc()), make_intLiteral ("1073741823", $e.loc()));}
    
    ;

lower_bound :
      expression
    ;

upper_bound :
      expression 
    ; 

call :
      primary LEFT_PAREN! (expression (','! expression)*  ','!?)? RIGHT_PAREN!       { $$ = $^(CALL, $*); }
    | compound_type_id LEFT_PAREN! (expression (','! expression)*  ','!?)? RIGHT_PAREN!       { $$ = $^(CALL, $*); }
    ;

/*******************************************/

/**************** ARITHMETIC ***************/
power : primary
    | primary (op="**" u_expr) { $$ = $^(BINOP, make_id("__pow__", $op.loc()), $primary, $u_expr); } 
    ; 

u_expr : power 
    | op="-" u_expr { $$ = $^(UNOP, make_id("__neg__", $op.loc()), $u_expr); }
    | op="+" u_expr { $$ = $^(UNOP, make_id("__pos__", $op.loc()), $u_expr); } 
    ;

m_expr : u_expr
    | m_expr op="*" u_expr { $$ = $^(BINOP, make_id("__mul__", $op.loc()), $m_expr, $u_expr); }
    | m_expr op="//" u_expr { $$ = $^(BINOP, make_id("__floordiv__", $op.loc()), $m_expr, $u_expr); }
    | m_expr op="/" u_expr { $$ = $^(BINOP, make_id("__floordiv__", $op.loc()), $m_expr, $u_expr); }
    | m_expr op="%" u_expr { $$ = $^(BINOP, make_id("__mod__", $op.loc()), $m_expr, $u_expr); } 
    ;

a_expr : m_expr
    | a_expr op="+" m_expr { $$ = $^(BINOP, make_id("__add__", $op.loc()), $a_expr, $m_expr); }
    | a_expr op="-" m_expr { $$ = $^(BINOP, make_id("__sub__", $op.loc()), $a_expr, $m_expr); } 
    ; 

/*Jinge get some comparisons working, but still need implementing*/
comparison :
      a_expr
    | L=a_expr op=comp_operator R=a_expr                      { $$ = $^(COMPARE, $op, $L, $R); }
    | L=left_comparison op=comp_operator R=a_expr             { $$ = $^(COMPARE, $op, $L, $R); }
    ;
left_comparison :
      L=a_expr op=comp_operator R=a_expr                      { $$ = $^(LEFT_COMPARE, $op, $L, $R); }
    | L=left_comparison op=comp_operator R=a_expr             { $$ = $^(LEFT_COMPARE, $op, $L, $R); }
    ;

comp_operator :
      op='<'            { $$ = make_id("__lt__", $op.loc()); }
    | op='>'            { $$ = make_id("__gt__", $op.loc()); }
    | op="=="           { $$ = make_id("__eq__", $op.loc()); }
    | op=">="           { $$ = make_id("__ge__", $op.loc()); }
    | op="<="           { $$ = make_id("__le__", $op.loc()); }
    | op="!="           { $$ = make_id("__ne__", $op.loc()); }
    | op="is"           { $$ = make_id("__is__", $op.loc()); }
    | op="is not"       { $$ = make_id("__isnot__", $op.loc()); }
    | op="not in"       { $$ = make_id("__notin__", $op.loc()); }
    | op="in"           { $$ = make_id("__in__", $op.loc()); }
    ;

expression :
      or_test
    | L=or_test IF M=or_test ELSE R=expression             { $$ = $^(IF_EXPR, $M, $L, $R); }
    ;
/**************************************************************/

or_test : and_test
    | or_test "or" and_test { $$ = $^(OR, $or_test, $and_test); }
    ;

and_test : not_test 
    | and_test "and" not_test { $$ = $^(AND, $and_test, $not_test); }
    ;

not_test : comparison 
    | op="not" not_test { $$ = $^(UNOP, make_id("__not__", $op.loc()), $not_test); }
    ;

/*******************************************/
/***************STATEMENTS******************/
expression_list :
      expression
    | expression ( ','! expression )+ (','!)?  { $$ = $^(TUPLE, $*); }
    | expression ','!                          { $$ = $^(TUPLE, $*); }
    ;

simple_stmt : 
      expression_stmt
    | assignment_stmt
    | pass_stmt
    | print_stmt
    | return_stmt
    | break_stmt    
    | continue_stmt
    | error
    ;
/***************** Dev-xg ******************/

expression_stmt :
    expression_list
    ;

assignment_stmt :
      target_list '='! right_side                           {$$ = $^(ASSIGN, $target_list, $right_side);}
    ;

target_list :
      target 
    | target (','! target)+ ','!?                                                            {$$ = $^(TARGETLIST, $*);}
    | target ','!                                                                            {$$ = $^(TARGETLIST, $*);}
    | LEFT_PAREN! target (','! target)+ ','!? RIGHT_PAREN!                                   {$$ = $^(TARGETLIST, $*);}
    | LEFT_SQUARE_BRACKET! target (','! target)+ ','!? RIGHT_SQUARE_BRACKET!                 {$$ = $^(TARGETLIST, $*);}
    | LEFT_PAREN! target ','! RIGHT_PAREN!                                                   {$$ = $^(TARGETLIST, $*);}
    | LEFT_PAREN! target RIGHT_PAREN!
    | LEFT_SQUARE_BRACKET! target ','!? RIGHT_SQUARE_BRACKET!                                {$$ = $^(TARGETLIST, $*);}
    ;

target :
      identifier
    | attributeref
    | subscription_assgin
    | slicing_assign
    | typed_id
    ;

subscription_assgin :
    e=primary LEFT_SQUARE_BRACKET! expression RIGHT_SQUARE_BRACKET!                             {$$ = $^(SUBSCRIPT_ASSIGN,make_id("__setitem__",$e.loc()), $*, $^(NEXT_VALUE));}
    ;

slicing_assign :
      e=primary LEFT_SQUARE_BRACKET! l=lower_bound ':'! u=upper_bound RIGHT_SQUARE_BRACKET!     {$$ = $^(SLICE_ASSIGN, make_id("__setslice__",$e.loc()), $e, $l, $u, $^(NEXT_VALUE));}
    | e=primary LEFT_SQUARE_BRACKET! l=lower_bound ':'! RIGHT_SQUARE_BRACKET!                   {$$ = $^(SLICE_ASSIGN, make_id("__setslice__",$e.loc()), $e, $l, make_intLiteral ("1073741823", $e.loc()), $^(NEXT_VALUE));}
    | e=primary LEFT_SQUARE_BRACKET! ':'! u=upper_bound RIGHT_SQUARE_BRACKET!                   {$$ = $^(SLICE_ASSIGN, make_id("__setslice__",$e.loc()), $e, make_intLiteral ("0", $e.loc()), $u, $^(NEXT_VALUE));}
    | e=primary LEFT_SQUARE_BRACKET! ':'! RIGHT_SQUARE_BRACKET!                                 {$$ = $^(SLICE_ASSIGN, make_id("__setslice__",$e.loc()), $e, make_intLiteral ("0", $e.loc()), make_intLiteral ("1073741823", $e.loc()), $^(NEXT_VALUE));}
    
    ;

right_side :
      expression_list
    | assignment_stmt
    ;

pass_stmt :
    PASS      { $$ = NULL; }
    ;

print_stmt :
      "print"! (expression (','! expression)*)?          { $$ = $^(PRINTLN, $*); }      
    | "print"! expression (','! expression)* ','!        { $$ = $^(PRINT, $*); }
    ;

return_stmt :
    "return"! {if (func_count == 0) error(yysource_location(), "return not properly in a funcdef"); } expression_list { $$ = $^(RETURN, $expression_list); }
    | r="return"! {if (func_count == 0) error(yysource_location(), "return not properly in a funcdef"); } { $$ = $^(RETURN, make_specialId("None", $r.loc())); }
    ;

break_stmt :
    "break"!             { if (loop_count == 0) error(yysource_location(), "@break not properly in a loop");
                            $$ = $^(BREAK); }
    ;

continue_stmt :
    "continue"!          { if (loop_count == 0) error(yysource_location(), "@continue not properly in a loop")                        ; $$ = $^(CONTINUE); }
    ;

compound_stmt :
      if_stmt
    | while_stmt
    | for_stmt
    | funcdef
    | classdef          
    ;

block :
      stmt_list NEWLINE!        { $$ = $^(BLOCK, $*); }
    | NEWLINE! INDENT! statement+ DEDENT! { $$ = $^(BLOCK, $*); }
    ;

native_block :
      "native"! stringliteral NEWLINE!                         { $$ = $^(BLOCK, $^(NATIVE, $stringliteral)); }
    | NEWLINE! INDENT! "native"! stringliteral NEWLINE! DEDENT! { $$ = $^(BLOCK, $^(NATIVE, $stringliteral)); }
    ;

statement :
      stmt_list NEWLINE!  
    | compound_stmt  
    ;

stmt_list :
    simple_stmt (';'! simple_stmt)* ';'!?     { $$ = $^(STMTLIST, $*); }
    ;

/******************* compound statement ****************/

if_stmt : 
    IF! { if_count += 1; has_class = true; } expression ':'! for_while_if (elif_stmt)? { $$ = $^(IF, $*); if_count -= 1}
    ;

elif_stmt:
    ELSE! ':'! for_while_if
    | ELIF! expression ':'! for_while_if (elif_stmt)? { $$ = $^(IF, $*); }
    ;

while_stmt :
    WHILE! { loop_count += 1; has_class = true; } expression ':'! for_while_if { loop_count -= 1; } (ELSE! ':'! for_while_if)? { $$ = $^(WHILE, $*); } 
    ;

for_stmt :
    FOR! { loop_count += 1; has_class = true; } target_list IN! expression_list ':'! for_while_if { loop_count -= 1; } (ELSE! ':'! for_while_if)? { $$ = $^(FOR, $*); }
    ;

for_while_if : 
    NEWLINE! INDENT! statement+ DEDENT!  { $$ = $^(STMTLIST, $*); }
    | stmt_list NEWLINE!
    ;

/************* Function Definition **************/

funcdef :
    "def"! funcname LEFT_PAREN! parameter_list RIGHT_PAREN! ("::"! type)? ':'! native_block { $$ = $^(DEF, $*); }
    | "def"! funcname LEFT_PAREN! parameter_list RIGHT_PAREN! { if (loop_count > 0 or if_count > 0) error(yysource_location(), "cannot def in loop or condition") ; func_count += 1; has_class = true; } ("::"! type)? ':'! block   { $$ = $^(DEF, $*); func_count -= 1; } 
    ;

parameter_list :
     (parameter ','!)* parameter ','!?     { $$ = $^(FORMALSLIST, $*); }
    | /*EMPTY*/                       { $$ = $^(FORMALSLIST); }
    ;

parameter :
    identifier
    | typed_id    
    ;

funcname :
    identifier
    ;

/************************************************/

/************* Class Definition *****************/
classdef :
    "class"! { if (has_class == true) error(yysource_location(), "cannot define a class inside others!"); has_class = true; } classname "of"! type_formals_list ':'! block      { $$ = $^(CLASS, $*); has_class = false; }
    | "class"! { if (has_class == true) error(yysource_location(), "cannot define a class inside others!"); has_class = true; } classname ':'! block  { $$ = $^(CLASS, $classname, $^(TYPE_FORMALS), $block); has_class = false; }
    ;

classname :
    identifier          
    ;

type_formals_list :
    LEFT_SQUARE_BRACKET! (type_var ','!)* type_var RIGHT_SQUARE_BRACKET!     { $$ = $^(TYPE_FORMALS, $*); }
    | type_var                              { $$ = $^(TYPE_FORMALS, $*); }
    ;

/************************************************/
/*************** STATIC TYPING ******************/
typed_id :
      identifier "::"! type         { $$ = $^(TYPED_ID, $*); }
    ;

type :
      type_id
    | type_var
    | LEFT_PAREN! type_list RIGHT_PAREN! "->"! type    { $$ = $^(FUNCTION_TYPE, $type, $type_list); }
    ;

type_var :
      '$'! identifier      { $$ = $^(TYPE_VAR, $identifier); }
    ;

type_list :
     (type ','!)* type?              { $$ = $^(TYPE_LIST, $*); }
    ;

type_id :
    compound_type_id
    | identifier                          { $$ = $^(TYPE, $identifier, $^(TYPE_LIST)); }
    ;

compound_type_id :
      identifier "of"! LEFT_SQUARE_BRACKET! type_list RIGHT_SQUARE_BRACKET!    { $$ = $^(TYPE, $*); }
    | identifier "of"! type               { $$ = $^(TYPE, $identifier, $^(TYPE_LIST, $type)); }
    ;

/************************************************/
/*****************  FILE I/O ********************/

/*
file_input :
    (NEWLINE! | statement)*
    ;

interactive_input :
      NEWLINE!
    | compound_stmt NEWLINE
    ;

eval_input :
    expression_list NEWLINE*
    ;

input_input :
    expression_list NEWLINE
    ;
*/

/************************************************/

error : 
      ERROR_LONGSTRING_SINGLEQUOTE              { error(yysource_location(), "Error on long string single quote!"); }
    | ERROR_LONGSTRING_DOUBLEQUOTE              { error(yysource_location(), "Error on long string double quote!"); }
    | ERROR_RAW_LONGSTRING_SINGLEQUOTE          { error(yysource_location(), "Error on raw long string single quote!"); }
    | ERROR_RAW_LONGSTRING_DOUBLEQUOTE          { error(yysource_location(), "Error on raw long string double quote!"); }
    | ERROR_SHORTSTRING                         { error(yysource_location(), "Error on short string!"); }
    | ERROR_RAW_SHORTSTRING                     { error(yysource_location(), "Error on raw short string!"); }
    | ERROR_CHARACTER                           { error(yysource_location(), "Error characters!"); }
    | ERROR_STMTS                               { error(yysource_location(), "Error statements!"); }
    ;
/*********************************************/

/*** LEXICAL DEFINITIONS ***/

/* Normally, throw away whitespace other than newline. */

LEFT_PAREN : '(' { paren_count += 1 ; } ;
RIGHT_PAREN : ')' { if (paren_count) paren_count -= 1 ; } ;
LEFT_SQUARE_BRACKET : '[' { square_bracket_count += 1 ; } ;
RIGHT_SQUARE_BRACKET : ']' { if (square_bracket_count) square_bracket_count -= 1 ; } ;
LEFT_CURLY_BRACKET : '{' { curly_bracket_count += 1 ; } ;
RIGHT_CURLY_BRACKET : '}' { if (curly_bracket_count) curly_bracket_count -= 1 ; } ;

_NONNEWLINE : _ANY - '\n' ;
_NONNEWLINE_NONSLASH : _ANY - ('\n' | '\\') ;

COMMENT : _BOL (' ' | '\t')*  '#' (_NONNEWLINE* "\\\n")* _NONNEWLINE* _NONNEWLINE_NONSLASH '\n' %prefer
          {
            YYIGNORE;}
        
        | (' ' | '\t')*  '#' (_NONNEWLINE* "\\\n")* _NONNEWLINE* _NONNEWLINE_NONSLASH _EOL %prefer
          {

            YYIGNORE;}
        
        ;

NEWLINE : '\n' { 
                  if ( paren_count > 0 || square_bracket_count > 0 || curly_bracket_count > 0 ) 
                  {
                    YYIGNORE;
                  }
                } ;

_NONZERODIGIT : '1' .. '9' ;

SPECIALID : "True" | "False" | "None" ; 

ERROR_STMTS :
      "as"
    | "assert"
    | "del"
    | "except"
    | "exec"
    | "from"
    | "finally"
    | "future"
    | "global"
    | "import"
    | "lambda"
    | "raise"
    | "try"
    | "with"
    | "yield"
    ;
    
ID : (_LETTER | '_') (_LETTER | _DIGIT | '_')*  ;

_DECIMAL : _NONZERODIGIT _DIGIT* | '0' ;
_OCTDIGIT : '0' .. '7' ;
_OCTINTEGER : '0' _OCTDIGIT+ ;
_HEXINTEGER : '0' ('x' | 'X') _HEX+ ;

INT_LITERAL :
      _DECIMAL                { if(strtol($TEXT, NULL, 10) > 1073741824) error(yysource_location(), "int can't be that large!"); }
    | _OCTINTEGER             { if(strtol($TEXT, NULL, 8) > 1073741824)  error(yysource_location(), "oct can't be that large!"); }
    | _HEXINTEGER             { if(strtol($TEXT, NULL, 16) > 1073741824) error(yysource_location(), "hex can't be that large!"); }
    ;

_RAWESCAPESEQ : '\\' _ANY ;
_RAWSHORTSTRINGITEM1 : _ANY - ('\'' | '\n') | _RAWESCAPESEQ ;
_RAWSHORTSTRINGITEM2 : _ANY - ('\"' | '\n') | _RAWESCAPESEQ ;
_RAWLONGSTRINGITEM : _ANY - '\\' | _RAWESCAPESEQ ;

_RAWSTRINGPREFIX : 'r' | 'R' ;
_RAWSHORTSTRING : '\'' _RAWSHORTSTRINGITEM1* '\'' |
                  '\"' _RAWSHORTSTRINGITEM2* '\"' ;
_NONSINGLEQUOTE : _ANY - '\'' ;
_NONDOUBLEQUOTE : _ANY - '\"' ;

_RAWNONSINGLEQUOTE : _ANY - ('\'' | '\\') | _RAWESCAPESEQ ;
_RAWNONDOUBLEQUOTE : _ANY - ('\"' | '\\') | _RAWESCAPESEQ ;

_RAWLONGSTRINGITEM1 : (_RAWNONSINGLEQUOTE* ('\''_RAWNONSINGLEQUOTE | "\'\'"_RAWNONSINGLEQUOTE)* _RAWNONSINGLEQUOTE*) ;
_RAWLONGSTRINGITEM2 : (_RAWNONDOUBLEQUOTE* ('\"'_RAWNONDOUBLEQUOTE | "\"\""_RAWNONDOUBLEQUOTE)* _RAWNONDOUBLEQUOTE*) ;

_RAWLONGSTRING : "\'\'\'" _RAWLONGSTRINGITEM1* "\'\'\'" 
              | "\"\"\"" _RAWLONGSTRINGITEM2* "\"\"\"" ;



_ESCAPESEQ : _RAWESCAPESEQ | '\\' _OCTDIGIT | '\\' _OCTDIGIT _OCTDIGIT | '\\' _OCTDIGIT _OCTDIGIT _OCTDIGIT ;
_LONGSTRINGITEM : _ANY - ('\\') | _ESCAPESEQ ;
_SHORTSTRINGITEM1 : _ANY - ('\n' | '\'') | _ESCAPESEQ ;
_SHORTSTRINGITEM2 : _ANY - ('\n' | '\"') | _ESCAPESEQ ;
_SHORTSTRING : '\'' _SHORTSTRINGITEM1* '\'' |
              '\"' _SHORTSTRINGITEM2* '\"' ;
_LONGNONSINGLEQUOTE : _ANY - ('\'' | '\\') | _ESCAPESEQ ;
_LONGNONDOUBLEQUOTE : _ANY - ('\"' | '\\') | _ESCAPESEQ ;
_LONGSTRINGITEM1 : _LONGNONSINGLEQUOTE* ('\''_LONGNONSINGLEQUOTE | "\'\'"_LONGNONSINGLEQUOTE)* _LONGNONSINGLEQUOTE* ;
_LONGSTRINGITEM2 : _LONGNONDOUBLEQUOTE* ('\"'_LONGNONDOUBLEQUOTE | "\"\""_LONGNONDOUBLEQUOTE)* _LONGNONDOUBLEQUOTE* ;
_LONGSTRING : "\'\'\'" _LONGSTRINGITEM1* "\'\'\'"
              | "\"\"\"" _LONGSTRINGITEM2* "\"\"\"" ;

STRING : _SHORTSTRING | _LONGSTRING ;
RAWSTRING : _RAWSTRINGPREFIX (_RAWSHORTSTRING | _RAWLONGSTRING) ;

/**************************** Error Handling *************************/

ERROR_LONGSTRING_SINGLEQUOTE : "\'\'\'" _LONGSTRINGITEM1* _EOF ;
ERROR_LONGSTRING_DOUBLEQUOTE : "\"\"\""  _LONGSTRINGITEM2* _EOF ;

ERROR_RAW_LONGSTRING_SINGLEQUOTE : _RAWSTRINGPREFIX "\'\'\'" _RAWLONGSTRINGITEM1* _EOF ;
ERROR_RAW_LONGSTRING_DOUBLEQUOTE : _RAWSTRINGPREFIX "\"\"\""  _RAWLONGSTRINGITEM2* _EOF ;

ERROR_SHORTSTRING :
      '\'' _SHORTSTRINGITEM1*
    | '\"' _SHORTSTRINGITEM2*
    ;
ERROR_RAW_SHORTSTRING :
      _RAWSTRINGPREFIX '\'' _RAWSHORTSTRINGITEM1*
    | _RAWSTRINGPREFIX '\"' _RAWSHORTSTRINGITEM2*
    ;
ERROR_CHARACTER : ('|' | '&' | '^' | "<<" | ">>" | '~') ; /* More error characters to be implemented. */


/********************************************************************************/


NEWLINE_WITH_BACKSLASH : "\\\n" (' ' | '\t')* { YYIGNORE ; } ;

INDENT_BLANKLINE : _BOL (' ' | '\t')* '\n' %prefer { YYIGNORE ; };
INDENT : _BOL (' ' | '\t')*  %prefer
{
  if ( paren_count || square_bracket_count || curly_bracket_count ) YYIGNORE;
  else {
    if (first_nonblank_line && $TEXT_SIZE != 0) {
      indentation_error();
      YYIGNORE;
    }
    if (!first_nonblank_line) {
      int equivalent_blank_count = calculate_equivalent_blanks($TEXT);
      if (indent_unit.empty()) {
        if (equivalent_blank_count != 0) {
          indent_unit.push(equivalent_blank_count);
          total_blank_count += equivalent_blank_count;
          YYSET_TOKEN(INDENT);
        }
        else {
          YYIGNORE;
        }
      }
      else {
        if (equivalent_blank_count == total_blank_count) {
          YYIGNORE;
        }
        else if (equivalent_blank_count > total_blank_count) {
          int indent_diff = equivalent_blank_count - total_blank_count;
          total_blank_count = equivalent_blank_count;
          indent_unit.push(indent_diff);
          YYSET_TOKEN(INDENT);
        }
        else {
          int difference = total_blank_count - equivalent_blank_count;
          while (difference > 0) {
            int last_indent = indent_unit.top();
            difference -= last_indent;
            if (difference < 0) {
              indentation_error(last_indent, difference+last_indent);
            }
            else {
              indent_unit.pop();
              yyqueue_token(DEDENT, 0, NULL, $TEXT, $TEXT_SIZE);
            }
          }
          total_blank_count = equivalent_blank_count;
          YYIGNORE;
        }
      }
    }
    if (first_nonblank_line && $TEXT_SIZE == 0) {
      first_nonblank_line = false;
      YYIGNORE;
    }
  }
} ;


WS : (' ' | '\t')* _EOL { YYIGNORE ; }
  | (' ' | '\t')* { YYIGNORE ; } ;

%%

bool debugParser;

/** Create a new ID token whose text is TEXT, and whose location is LOC. */
static AST_Ptr
make_id (const char* text, Location_Type loc)
{
    AST_Ptr result = AST::make_token (ID, text);
    result->set_loc (loc);
    return result;
}

static AST_Ptr
make_intLiteral (const char* text, Location_Type loc)
{
    AST_Ptr result = AST::make_token (INT_LITERAL, text);
    result->set_loc (loc);
    return result;
}

static AST_Ptr
make_specialId (const char* text, Location_Type loc)
{
    AST_Ptr result = AST::make_token (SPECIALID, text);
    result->set_loc (loc);
    return result;
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void indentation_error(int expected_indent, int actual_indent)
{
  error(yysource_location(), "bad indentation\n");
}

void indentation_error() {
  error(yysource_location(), "bad indentation\n");
}

int calculate_equivalent_blanks(const char* text) {
  int blank_count = 0;
  int quotient = 0;
  const char* it;
  for (it = text; *it; ++it) {
    if (*it == ' ') {
      blank_count++;
    }
    else if (*it == '\t') {
      quotient = blank_count / 8;
      blank_count = 8 * (quotient + 1);
    }
  }
  return blank_count;
}

void
parse (FILE* f, const gcstring& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}
