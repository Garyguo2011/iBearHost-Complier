/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%{
  #include <string>
  #include "apyc.h"
  #include "ast.h"

  using namespace std;

  /** Make sure garbage collection is initialized. */
  static GCINIT _gcdummy;

  static AST_Ptr theTree;

  /* Utilities */

  /** Return a new ID node, where the text of the identifier is given by
   *  TOKEN. */
  static AST_Ptr make_id (const char* token, Location_Type loc);


  /* Variables for lexer */
  static int paren_count = 0 ;
  static int square_bracket_count = 0;
  static int curly_bracket_count = 0;

  static int indent_unit = 0;
  static int indent_level = 0;
  static bool first_nonblank_line = true;
  
%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */

%token PRINTLN "@println"
%token EMPTY 
%token MODULE "@module"
%token ID "@id"
%token UNOP "@unop"
%token STRING_LITERAL "@string_literal"
%token INT_LITERAL "@int_literal"
%token AND "and"
%token BREAK "break"
%token CLASS "class"
%token CONTINUE "continue"
%token DEF "def"
%token ELIF "elif"
%token ELSE "else"
%token FOR "for"
%token IF "if"
%token IN "in"
%token IS "is"
%token NOT "not"
%token OR "or"
%token PASS "pass"
%token PRINT "print"
%token RETURN "return"
%token WHILE "while"
%token STRING "@string"
%token RAWSTRING "@rawstring"
%token INDENT "@indent"
%token DEDENT "@dedent"
%token NEWLINE
%token COMMENT
%token BLANKLINE
%token INDENT_BLANKLINE
%token LEFT_PAREN
%token RIGHT_PAREN
%token LEFT_SQUARE_BRACKET
%token RIGHT_SQUARE_BRACKET
%token LEFT_CURLY_BRACKET
%token RIGHT_CURLY_BRACKET

%token LEFT_COMPARE "@left_compare"
%token COMPARE "@compare"
%token BINOP "@binop"

/* FIXME: MORE... */

/* GLR parsing is useful for cases where the parser must make a reduction before
 * it has sufficient information to know which reduction to make.  For example,
 * consider a statement that begins
 *      a[i], b[j], c
 * (it's not useful, but is valid Python as it stands).  As a tuple, this 
 * consists of a list of expressions.  a[i] is a subscription, and corresponds
 * to a (subscript ...) AST.  But if we have
 *      a[i], b[j], c = L
 * then the a[i] should create a subscript_assign.  If you try to handle this
 * by having two rules for subscription, one for the first case and one 
 * for the second, the parser has to decide which to choose just after seeing
 * seeing a[i], but long before seeing "=", which is how one tells which
 * translation is appropriate.  A GLR parser will hold off on this decision
 * until is reaches the =. */

%glr-parser

/* If you use the GLR features, Bison will report conflicts.  Without GLR,
 * a conflict generally means an error.  With GLR, it could mean an error,
 * or it could indicate conflicts that the GLR algorithm will correctly resolve.
 * There's really no way to know without testing.  When you get conflicts
 * THAT YOU EXPECT you can record here these expectations by reporting how
 * many reduce/reduce (%expect-rr) and shift-reduce (%expect) you expect. 
 * Before increasing these counts, make sure you understand what causes your
 * conflicts and that GLR will resolve them.  Don't expect too many (our solution
 * has 20 overall) and try to remove conflicts rather than tolerating them.
 * A conflict will occur when there is a situation where Bison cannot decide
 * on the basis of the input so far whether to perform a reduction.  The 
 * conflict is OK if it will become clear later on in the input what should
 * have been done. */
%expect-rr 73
%expect 16

%left OR
%left AND
%left "<" "<=" ">" ">=" "!=" "==" "is" "is not" "in" "not in"
%left "+" "-"
%left "*" "/" "%"
%left "**"

%%
program : stmt_list   { theTree = $^(MODULE, $*); $$ = NULL; }
        ;

// REPLACE THE FOLLOWING WITH SOMETHING REAL.  (These are incomplete examples.)

stmt_list : print_stmt NEWLINE!
    ;

print_stmt : "print"! expression_list 
                      { $$ = $^(PRINTLN, $*); }
    ;

expression_list :
      expression /*(","! expression)* */
    | /*empty*/
    ;

expression :
      INT_LITERAL     
    | string_literal
    | conditional_expression
    | L=expression OP=algebra_operator R=expression   { $$ = $^(BINOP, $OP, $L, $R); }
    | '('! expression ')'!
    ;

/****************** XGUO-dev *********************/
/****************** XGUO-dev *********************/

comparison :
    L=left_comparison OP=comp_operator R=expression         { $$ = $^(COMPARE, $OP, $L, $R) ;}
    ;

left_comparison : 
    E=expression                                          { $$ = $E ;}
    | L=left_comparison OP=comp_operator R=expression     { $$ = $^(LEFT_COMPARE, $OP, $L, $R) ;}
    ;

comp_operator :
      op="<"                      { $$ = make_id("__lt__", $op.loc()); }
    | op=">"                      { $$ = make_id("__gt__", $op.loc()); }
    | op="=="                     { $$ = make_id("__eq__", $op.loc()); } 
    | op=">="                     { $$ = make_id("__ge__", $op.loc()); }
    | op="<="                     { $$ = make_id("__le__", $op.loc()); }
    | op="!="                     { $$ = make_id("__ne__", $op.loc()); }
    | op="is"                     { $$ = make_id("__is__", $op.loc()); }
    | op="is not"                 { $$ = make_id("__isnot__", $op.loc()); }
    | op="in"                     { $$ = make_id("__in__", $op.loc()); }
    | op="not in"                 { $$ = make_id("__notin__", $op.loc()); }
    ;

algebra_expr :
    L=expression OP=algebra_operator R=expression   { $$ = $^(BINOP, $OP, $L, $R); }
    ;

algebra_operator :
      op = "+"                    { $$ = make_id("__add__", $op.loc()); }
    | op = "-"                    { $$ = make_id("__sub__", $op.loc()); }
    | op = "*"                    { $$ = make_id("__mul__", $op.loc()); }
    | op = "/"                    { $$ = make_id("__floordiv__", $op.loc()); }
    | op = "//"                    { $$ = make_id("__floordiv__", $op.loc()); }
    | op = "%"                    { $$ = make_id("__mod__", $op.loc()); }
    | op = "**"                   { $$ = make_id("__pow__", $op.loc()); }
    ;

/****************** XGUO-dev *********************/

conditional_expression :
    not_test
    | L=conditional_expression AND R=conditional_expression { $$ = $^(AND, $L, $R); }
    | L=conditional_expression OR R=conditional_expression  { $$ = $^(OR, $L, $R); }
    ;

not_test :
    comparison      //comp_operator
    | NOT not_test      { $$ = $^(UNOP, make_id("__not__", $NOT.loc()), $not_test); }
    ;

string_literal :
      STRING            { $$ = $^(STRING_LITERAL, $*); } // FIXME
    ;
    

/*** LEXICAL DEFINITIONS ***/

/* Normally, throw away whitespace other than newline. */

_NONZERODIGIT : '1' .. '9' ;

ID : (_LETTER | '_') (_LETTER | _DIGIT | '_')* ;

_DECIMAL : _NONZERODIGIT _DIGIT* | '0' ;
_OCTDIGIT : '0' .. '7' ;
_OCTINTEGER : '0' _OCTDIGIT+ ;
_HEXINTEGER : '0' ('x' | 'X') _HEX+ ;

INT_LITERAL : _DECIMAL | _OCTINTEGER | _HEXINTEGER ;

_RAWESCAPESEQ : '\\' _ANY ;
_RAWSHORTSTRINGITEM1 : _ANY - ('\'' | '\n') | _RAWESCAPESEQ ;
_RAWSHORTSTRINGITEM2 : _ANY - ('\"' | '\n') | _RAWESCAPESEQ ;
_RAWLONGSTRINGITEM : _ANY - '\\' | _RAWESCAPESEQ ;

_RAWSTRINGPREFIX : 'r' | 'R' ;
_RAWSHORTSTRING : '\'' _RAWSHORTSTRINGITEM1* '\'' |
                  '\"' _RAWSHORTSTRINGITEM2* '\"' ;
_NONSINGLEQUOTE : _ANY - '\'' ;
_NONDOUBLEQUOTE : _ANY - '\"' ;

_RAWNONSINGLEQUOTE : _ANY - ('\'' | '\\') | _RAWESCAPESEQ ;
_RAWNONDOUBLEQUOTE : _ANY - ('\"' | '\\') | _RAWESCAPESEQ ;

_RAWLONGSTRING : "\'\'\'" (_RAWNONSINGLEQUOTE* ('\''_RAWNONSINGLEQUOTE | "\'\'"_RAWNONSINGLEQUOTE)* _RAWNONSINGLEQUOTE*)* "\'\'\'" 
              | "\"\"\"" (_RAWNONDOUBLEQUOTE* ('\"'_RAWNONDOUBLEQUOTE | "\"\""_RAWNONDOUBLEQUOTE)* _RAWNONDOUBLEQUOTE*)* "\"\"\"" ;


_ESCAPESEQ : _RAWESCAPESEQ | '\\' _OCTDIGIT | '\\' _OCTDIGIT _OCTDIGIT | '\\' _OCTDIGIT _OCTDIGIT _OCTDIGIT ;
_LONGSTRINGITEM : _ANY - ('\\') | _ESCAPESEQ ;
_SHORTSTRINGITEM1 : _ANY - ('\n' | '\'') | _ESCAPESEQ ;
_SHORTSTRINGITEM2 : _ANY - ('\n' | '\"') | _ESCAPESEQ ;
_SHORTSTRING : '\'' _SHORTSTRINGITEM1* '\'' |
              '\"' _SHORTSTRINGITEM2* '\"' ;
_LONGNONSINGLEQUOTE : _ANY - ('\'' | '\\') | _ESCAPESEQ ;
_LONGNONDOUBLEQUOTE : _ANY - ('\"' | '\\') | _ESCAPESEQ ;
_LONGSTRING : "\'\'\'" (_LONGNONSINGLEQUOTE* ('\''_LONGNONSINGLEQUOTE | "\'\'"_LONGNONSINGLEQUOTE)* _LONGNONSINGLEQUOTE*)* "\'\'\'" 
              | "\"\"\"" (_LONGNONDOUBLEQUOTE* ('\"'_LONGNONDOUBLEQUOTE | "\"\""_LONGNONDOUBLEQUOTE)* _LONGNONDOUBLEQUOTE*)* "\"\"\"" ;

STRING : _SHORTSTRING | _LONGSTRING ;
RAWSTRING : _RAWSTRINGPREFIX (_RAWSHORTSTRING | _RAWLONGSTRING) ;

LEFT_PAREN : '(' { paren_count += 1 ; } ;
RIGHT_PAREN : ')' { if (paren_count) paren_count -= 1 ; } ;
LEFT_SQUARE_BRACKET : '[' { square_bracket_count += 1 ; } ;
RIGHT_SQUARE_BRACKET : ']' { if (square_bracket_count) square_bracket_count -= 1 ; } ;
LEFT_CURLY_BRACKET : '{' { curly_bracket_count += 1 ; } ;
RIGHT_CURLY_BRACKET : '}' { if (curly_bracket_count) curly_bracket_count -= 1 ; } ;

NEWLINE_WITH_BACKSLASH : "\\\n" { YYIGNORE ; } ;
NEWLINE : '\n' { if ( paren_count || square_bracket_count || curly_bracket_count ) YYIGNORE; } ; 

_WS_NONNEWLINE : '\r' | '\t' | ' ' | '\f' ;
_NONNEWLINE : _ANY - '\n' ;
_NONNEWLINE_NONSLASH : _ANY - ('\n' | '\\') ; 

COMMENT : '#' (_NONNEWLINE* "\\\n")* _NONNEWLINE* _NONNEWLINE_NONSLASH '\n'  %prefer { YYIGNORE ; } ;

BLANKLINE : _WS_NONNEWLINE* '\n' { YYIGNORE ; } ;

INDENT_BLANKLINE : _BOL (' ' | '\t')* '\n' %prefer { YYIGNORE ; }; 
INDENT : _BOL (' ' | '\t')*  %prefer
{ 
  fprintf(stderr, "start indenting program, indent level is %d \n", indent_level);
  if (first_nonblank_line && $TEXT_SIZE != 0) {
    indentation_error();
    YYIGNORE;
  }
  if (!first_nonblank_line) {
    int equivalent_blank_count = calculate_equivalent_blanks($TEXT);
    if (indent_unit == 0) {
      indent_unit = equivalent_blank_count;
      if (equivalent_blank_count != 0) {
        YYSET_TOKEN(INDENT);
        fprintf(stderr, "INDENT \n");
        indent_level++;
      }
      else {
        YYIGNORE;
      }
    }
    else {
      int default_blank_count = indent_level * indent_unit;
      if (equivalent_blank_count % indent_unit != 0) {
        indentation_error(default_blank_count, equivalent_blank_count);
        YYIGNORE;
      }
      else {
        if (equivalent_blank_count == default_blank_count) {
          YYIGNORE;
        }
        else if (equivalent_blank_count == default_blank_count + indent_unit) {
          YYSET_TOKEN(INDENT);
          fprintf(stderr, "INDENT \n");
          indent_level++;
        }
        else {
          int new_indent_level = equivalent_blank_count / indent_unit;
          int difference = indent_level - new_indent_level;
          while (difference > 0) {
            yyqueue_token(DEDENT, 0);
            indent_level--;
            difference--;
          }
        }
      }
    }
  }
  if (first_nonblank_line && $TEXT_SIZE == 0) {
    first_nonblank_line = false;
    YYIGNORE;
  }
  fprintf(stderr, "ending indentation, indent level is %d \n \n \n \n", indent_level);
} ; 

WS : ('\t' | ' ')* { YYIGNORE ; } ;

%%

bool debugParser;

/** Create a new ID token whose text is TEXT, and whose location is LOC. */
static AST_Ptr
make_id (const char* text, Location_Type loc)
{
    AST_Ptr result = AST::make_token (ID, text);
    result->set_loc (loc);
    return result;
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void indentation_error(int expected_indent, int actual_indent) 
{
  fprintf(stderr, "expected %d actual %d \n", expected_indent, actual_indent);
}

void indentation_error() {
  fprintf(stderr, "indentation error");
}

int calculate_equivalent_blanks(const char* text) {
  int blank_count = 0;
  int quotient = 0;
  const char* it;
  for (it = text; *it; ++it) {
    if (*it == ' ') {
      blank_count++;
    }
    else if (*it == '\t') {
      quotient = blank_count / 8;
      blank_count = 8 * (quotient + 1);
    }
  }
  return blank_count;
}

void
parse (FILE* f, const gcstring& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}
