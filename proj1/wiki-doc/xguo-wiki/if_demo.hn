/* -*- mode: fundamental; c-file-style: "stroustrup"; indent-tabs-mode: nil -*- */

/* apyc: Bison Parser */

/* Authors: YOUR NAMES HERE */

%define semantic_tree_type "AST"

%{
  #include <string>
  #include "apyc.h"
  #include "ast.h"

  using namespace std;

  /** Make sure garbage collection is initialized. */
  static GCINIT _gcdummy;

  static AST_Ptr theTree;

  /* Utilities */

  /** Return a new ID node, where the text of the identifier is given by
   *  TOKEN. */
  static AST_Ptr make_id (const char* token, Location_Type loc);

%}

%debug
%define error_function error

/* A token declaration such as
 *   %token INDENT
 * declares a new integer constant INDENT, which serves as a syntactic category
 * (suitable for output by the lexer) identifying a kind of token, which we
 * also often refer to as INDENT. A declaration such as
 *   %token IF "if"
 * defines a constant IF and makes it the syntactic category for the token
 * "if".  The built-in function yyexternal_token_name(...) maps between 
 * syntactic categories (like IF) and the token strings defined in these 
 * %token declarations (like "if").  
 *
 * The Horn system uses tokens as leaf nodes and as AST node operators.  A
 * rule such as
 *     if_stmt: "if"^ expression ":"! ...
 * with no action, by default creates an AST node whose operator is an "if"
 * token (with syntactic category IF, given the %token declaration above).
 * When the node type does not correspond to a token that appears in the 
 * program, we define a dummy token type that serves only as an AST
 * node type.  For example, we can define
 *     %token DICT_DISPLAY ...
 * and then use
 *     dict_display: "{"! key_datum_list? "}"! 
 *              { $$ = $^(DICT_DISPLAY, $*); }
 * in the grammar (using DICT_DISPLAY only in actions, not as a grammar
 * symbol).
 *
 * In this skeleton, we've used a simple kludge to extract the printed forms
 * of AST operators from the operators themselves.  When a token such as IF
 * is the operator, yyexternal_token_name returns the operator name directly.
 * When there is no such correspondence, as with DICT_DISPLAY, we'll define
 *     %token DICT_DISPLAY "@dict_display"
 * Since "@dict_display" is not a valid token (it would be an error for this
 * to appear in any Python program) and does not appear in the grammar, this
 * declaration has no effect on the language recognized.  However, it
 * still provides an easy way to find the external name of an operator (just
 * strip off the leading "@").  (We can't just use "dict_display", since that
 * would tell Horn to define 'dict_display' as a token, whereas it would be a
 * simple identifier if it actually appeared in a Python program.  This is
 * where the kludginess comes in.) The AST_Tree::external_name method does
 * this conversion, converting tokens that are supposed to represent
 * node operators to printable strings.
 */


%token PRINTLN "@println"
%token EMPTY 
%token MODULE "@module"
%token ID "@id"
%token STRING_LITERAL "@string_literal"
%token INT_LITERAL "@int_literal"
%token AND "and"
%token BREAK "break"
%token CLASS "class"
%token CONTINUE "continue"
%token DEF "def"
%token ELIF "elif"
%token ELSE "else"
%token FOR "for"
%token IF "if"
%token IN "in"
%token IS "is"
%token NOT "not"
%token OR "or"
%token PASS "pass"
%token PRINT "print"
%token RETURN "return"
%token WHILE "while"
%token STRING "@string"
%token RAWSTRING "@rawstring"


/* FIXME: MORE... */

/* GLR parsing is useful for cases where the parser must make a reduction before
 * it has sufficient information to know which reduction to make.  For example,
 * consider a statement that begins
 *      a[i], b[j], c
 * (it's not useful, but is valid Python as it stands).  As a tuple, this 
 * consists of a list of expressions.  a[i] is a subscription, and corresponds
 * to a (subscript ...) AST.  But if we have
 *      a[i], b[j], c = L
 * then the a[i] should create a subscript_assign.  If you try to handle this
 * by having two rules for subscription, one for the first case and one 
 * for the second, the parser has to decide which to choose just after seeing
 * seeing a[i], but long before seeing "=", which is how one tells which
 * translation is appropriate.  A GLR parser will hold off on this decision
 * until is reaches the =. */

%glr-parser

/* If you use the GLR features, Bison will report conflicts.  Without GLR,
 * a conflict generally means an error.  With GLR, it could mean an error,
 * or it could indicate conflicts that the GLR algorithm will correctly resolve.
 * There's really no way to know without testing.  When you get conflicts
 * THAT YOU EXPECT you can record here these expectations by reporting how
 * many reduce/reduce (%expect-rr) and shift-reduce (%expect) you expect. 
 * Before increasing these counts, make sure you understand what causes your
 * conflicts and that GLR will resolve them.  Don't expect too many (our solution
 * has 20 overall) and try to remove conflicts rather than tolerating them.
 * A conflict will occur when there is a situation where Bison cannot decide
 * on the basis of the input so far whether to perform a reduction.  The 
 * conflict is OK if it will become clear later on in the input what should
 * have been done. */
%expect-rr 0
%expect 0

%%
program : stmt_list   { theTree = $^(MODULE, $*); $$ = NULL; }
        ;

// REPLACE THE FOLLOWING WITH SOMETHING REAL.  (These are incomplete examples.)

stmt_list : print_stmt '\n'!
    ;

print_stmt : "print"! expression_list 
                      { $$ = $^(PRINTLN, $*); }
    ;


if_stmt : IF expression ":" suite ( ELIF expression ":" suite )* (ELSE ":" suite)?
    ;

suite : stmt_list 
    ;

expression_list :
      expression (","! expression)*
    | /*empty*/
    ;

expression :
      INT_LITERAL
    | string_literal
    ;

string_literal :
      STRING            { $$ = $^(STRING_LITERAL, $*); } // FIXME
    ;


/*** LEXICAL DEFINITIONS ***/

/* Normally, throw away whitespace other than newline. */
* : (' ' | '\t' | '\r')+ ;

_NONZERODIGIT : '1' .. '9' ;

ID : (_LETTER | '_') (_LETTER | _DIGIT | '_')* ;

_DECIMAL : _NONZERODIGIT _DIGIT* | '0' ;
_OCTDIGIT : '0' .. '7' ;
_OCTINTEGER : '0' _OCTDIGIT+ ;
_HEXINTEGER : '0' ('x' | 'X') _HEX+ ;

INT_LITERAL : _DECIMAL | _OCTINTEGER | _HEXINTEGER ;

_RAWESCAPESEQ : '\\' _ANY ;
_RAWSHORTSTRINGITEM1 : _ANY - ('\'' | '\n') | _RAWESCAPESEQ ;
_RAWSHORTSTRINGITEM2 : _ANY - ('\"' | '\n') | _RAWESCAPESEQ ;
_RAWLONGSTRINGITEM : _ANY - '\\' | _RAWESCAPESEQ ;


_RAWSTRINGPREFIX : 'r' | 'R' ;
_RAWSHORTSTRING : '\'' _RAWSHORTSTRINGITEM1* '\'' |
                  '\"' _RAWSHORTSTRINGITEM2* '\"' ;
_NONSINGLEQUOTE : _ANY - '\'' ;
_NONDOUBLEQUOTE : _ANY - '\"' ;

_RAWNONSINGLEQUOTE : _ANY - ('\'' | '\\') | _RAWESCAPESEQ ;
_RAWNONDOUBLEQUOTE : _ANY - ('\"' | '\\') | _RAWESCAPESEQ ;

_RAWLONGSTRING : "\'\'\'" (_RAWNONSINGLEQUOTE* ('\''_RAWNONSINGLEQUOTE | "\'\'"_RAWNONSINGLEQUOTE)* _RAWNONSINGLEQUOTE*)* "\'\'\'" 
              | "\"\"\"" (_RAWNONDOUBLEQUOTE* ('\"'_RAWNONDOUBLEQUOTE | "\"\""_RAWNONDOUBLEQUOTE)* _RAWNONDOUBLEQUOTE*)* "\"\"\"" ;


_ESCAPESEQ : _RAWESCAPESEQ | '\\' _OCTDIGIT | '\\' _OCTDIGIT _OCTDIGIT | '\\' _OCTDIGIT _OCTDIGIT _OCTDIGIT ;
_LONGSTRINGITEM : _ANY - ('\\') | _ESCAPESEQ ;
_SHORTSTRINGITEM1 : _ANY - ('\n' | '\'') | _ESCAPESEQ ;
_SHORTSTRINGITEM2 : _ANY - ('\n' | '\"') | _ESCAPESEQ ;
_SHORTSTRING : '\'' _SHORTSTRINGITEM1* '\'' |
              '\"' _SHORTSTRINGITEM2* '\"' ;
_LONGNONSINGLEQUOTE : _ANY - ('\'' | '\\') | _ESCAPESEQ ;
_LONGNONDOUBLEQUOTE : _ANY - ('\"' | '\\') | _ESCAPESEQ ;
_LONGSTRING : "\'\'\'" (_LONGNONSINGLEQUOTE* ('\''_LONGNONSINGLEQUOTE | "\'\'"_LONGNONSINGLEQUOTE)* _LONGNONSINGLEQUOTE*)* "\'\'\'" 
              | "\"\"\"" (_LONGNONDOUBLEQUOTE* ('\"'_LONGNONDOUBLEQUOTE | "\"\""_LONGNONDOUBLEQUOTE)* _LONGNONDOUBLEQUOTE*)* "\"\"\"" ;

STRING : _SHORTSTRING | _LONGSTRING ;
RAWSTRING : _RAWSTRINGPREFIX (_RAWSHORTSTRING | _RAWLONGSTRING) ;


%%

bool debugParser;

/** Create a new ID token whose text is TEXT, and whose location is LOC. */
static AST_Ptr
make_id (const char* text, Location_Type loc)
{
    AST_Ptr result = AST::make_token (ID, text);
    result->set_loc (loc);
    return result;
}

int
AST::lineNumber ()
{
    return yylocation_line (loc ());
}

void
parse (FILE* f, const gcstring& name)
{
    if (debugParser)
        yydebug = 1;
    yypush_lexer (f, name);
    theTree = NULL;
    yyparse ();
    if (theTree != NULL) {
        theTree->print (cout, 0);
    }
}